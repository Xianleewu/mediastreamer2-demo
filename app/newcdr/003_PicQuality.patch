diff --git a/include/camera/camera.h b/include/camera/camera.h
index 2d1312b..1862ded 100755
--- a/include/camera/camera.h
+++ b/include/camera/camera.h
@@ -9,10 +9,14 @@ enum{
 };
 
 typedef enum {
-	ImageQuality1M = 0,
-	ImageQuality3M,
-	ImageQuality5M,
-	ImageQuality8M,
+	ImageQualityQQVGA = 0, /*160---120*/
+	ImageQualityQVGA,	   /*320---240*/
+	ImageQualityVGA,	   /*640---480*/
+	ImageQuality720P,	   /*1280--720*/
+	ImageQuality1080P,	   /*1920-1080*/
+	/*unsupported below*/
+	ImageQuality5M,	       /*2560-1920*/
+	ImageQuality8M,	       /*3264-2448*/
 }ImageQuality_t;
 
 
diff --git a/include/fwk_msg/fwk_gl_def.h b/include/fwk_msg/fwk_gl_def.h
index 476cea9..98a78a6 100644
--- a/include/fwk_msg/fwk_gl_def.h
+++ b/include/fwk_msg/fwk_gl_def.h
@@ -210,6 +210,13 @@ typedef struct{
 #define WRTC_VALUE_RESOLUTION_720P		("720P")
 #define WRTC_VALUE_RESOLUTION_1080P		("1080P")
 
+#define WRTC_CMD_SET_PICQUALITY			("PicQuality")
+#define WRTC_VALUE_PICQUALITY_QQVGA		("QQVGA")
+#define	WRTC_VALUE_PICQUALITY_QVGA		("QVGA")
+#define WRTC_VALUE_PICQUALITY_VGA		("VGA")
+#define WRTC_VALUE_PICQUALITY_720P		("720P")
+#define WRTC_VALUE_PICQUALITY_1080P		("1080P")
+
 
 #define WRTC_CMD_SET_RECORD_TIME			("RecordTime")
 #define WRTC_VALUE_RECORD_TIME_MINUTE		(60)
diff --git a/include/storage/StorageManager.h b/include/storage/StorageManager.h
index dcb05b0..c3fa0c8 100755
--- a/include/storage/StorageManager.h
+++ b/include/storage/StorageManager.h
@@ -35,8 +35,8 @@ long long totalDirSize(const char *path);
 #define SZ_1M ((unsigned long long)(1<<20))
 #define SZ_1G ((unsigned long long)(1<<30))
 //#define RESERVED_SIZE (SZ_1M * 300)
-#define RESERVED_SIZE ((unsigned long long)((SZ_1M*1500)/SZ_1M))
-#define LOOP_COVERAGE_SIZE (RESERVED_SIZE + ((SZ_1M*500)/SZ_1M))
+#define RESERVED_SIZE ((unsigned long long)((SZ_1M*1000)/SZ_1M))
+#define LOOP_COVERAGE_SIZE (RESERVED_SIZE + ((SZ_1M*300)/SZ_1M))
 
 #define FILE_SZ_1M ((uint32_t)(1*1024*1024))
 
@@ -132,6 +132,7 @@ public:
 	void dbAddFileByTransaction(Elem *elem);
 	void dbDelFile(char const *file);
 	int generateFile(time_t &now, String8 &file, int cam_type, fileType_t type);
+	int generateFile2(time_t now, String8 &file, int cam_type, fileType_t type);
 	int saveVideoFrameToBmpFile(VideoFrame* videoFrame, const char* bmpFile);
 	int savePicture(void* data, int size, int fd);
 	int checkDirs();
diff --git a/include/window/windows.h b/include/window/windows.h
index b10d18b..5910e31 100755
--- a/include/window/windows.h
+++ b/include/window/windows.h
@@ -149,6 +149,10 @@ class RecordPreview : public MainWindow
 {
 private:
 	bool SdcardState;
+	bool isThumb;
+
+	ImageQuality_t pictuQuality;
+	ImageQuality_t thumbQuality;
 public:
 	RecordPreview(CdrMain* cdrMain);
 	~RecordPreview();
@@ -165,6 +169,8 @@ public:
 	int setRecordState(int state);
 	void waitForStorageMount(int timeout_ms);
 
+	void setPictureQuality(int quality);
+	
 	void startPreview();
 	void startPreview(int cam_type);
 	void stopPreview(int cam_type);
@@ -641,7 +647,9 @@ public:
 	bool getUvcState();
 	int notifyWebRtc(unsigned char *pbuf, int size);
 	int take_picture(void);
-        int impact_occur(void);
+    int impact_occur(void);
+	
+	int setPicModeWebRTC(int value);
 	int setVideoModeWebRTC(int value);
 	int setRecordTimeWebRTC(int value);
 	int  setExposureWebRTC(int value);
diff --git a/src/camera/CdrCamera.cpp b/src/camera/CdrCamera.cpp
index 23a838a..7cc5a41 100755
--- a/src/camera/CdrCamera.cpp
+++ b/src/camera/CdrCamera.cpp
@@ -286,13 +286,31 @@ void CdrCamera::setImageQuality(ImageQuality_t quality)
 	//params.dump();
 
 	switch(quality) {
-	case ImageQuality1M:
+	case ImageQualityQQVGA:
+		{
+			w = 160;
+			h = 120;
+		}
+		break;
+	case ImageQualityQVGA:
+		{
+			w = 320;
+			h = 240;
+		}
+		break;
+	case ImageQualityVGA:
+		{
+			w = 640;
+			h = 480;
+		}
+		break;
+	case ImageQuality720P:
 		{
 			w = 1280;
 			h = 720;
 		}
 		break;
-	case ImageQuality3M:
+	case ImageQuality1080P:
 		{
 			w = 1920;
 			h = 1080;
diff --git a/src/fwk_msg/view/fwk_view.cpp b/src/fwk_msg/view/fwk_view.cpp
index b9aec47..4418f35 100644
--- a/src/fwk_msg/view/fwk_view.cpp
+++ b/src/fwk_msg/view/fwk_view.cpp
@@ -1352,6 +1352,62 @@ String8 handle_remote_message_sync(unsigned char *pbuffer, int size)
 				result += wrtc_path.c_str();
 				return result;
 			}
+			else if(strcasecmp(pname,WRTC_CMD_SET_PICQUALITY) == 0)
+			{
+				const char* pvalue=root["value"].asCString();
+				int ret = -1;
+				Json::Value lroot;
+				Json::FastWriter writer;
+				Json::Value wrtc_rsp;
+				string wrtc_path;
+
+				db_msg("fwk_msg handle_remote_message_sync name=%s pvalue=%s\n", pname, pvalue);
+
+				wrtc_rsp["name"] = WRTC_CMD_SET_PICQUALITY;
+				if(pvalue != NULL)
+				{
+					wrtc_rsp["value"] = pvalue;
+					if(strcasecmp(pvalue, WRTC_VALUE_PICQUALITY_QQVGA) == 0)
+					{
+						ret = pView_cdrMain->setPicModeWebRTC(ImageQualityQQVGA);
+					}
+					else if(strcasecmp(pvalue, WRTC_VALUE_PICQUALITY_QVGA) == 0)
+					{
+						ret = pView_cdrMain->setPicModeWebRTC(ImageQualityQVGA);
+					}
+					else if(strcasecmp(pvalue, WRTC_VALUE_PICQUALITY_VGA) == 0)
+					{
+						ret = pView_cdrMain->setPicModeWebRTC(ImageQualityVGA);
+					}
+					else if(strcasecmp(pvalue, WRTC_VALUE_PICQUALITY_720P) == 0)
+					{
+						ret = pView_cdrMain->setPicModeWebRTC(ImageQuality720P);
+					}
+					else if(strcasecmp(pvalue, WRTC_VALUE_PICQUALITY_1080P) == 0)
+					{
+						ret = pView_cdrMain->setPicModeWebRTC(ImageQuality1080P);
+					}
+					else
+					{
+						ret = -1;
+					}
+
+				}
+				if(0 == ret)
+				{
+					wrtc_rsp["result"]=true;
+				}
+				else
+				{
+					wrtc_rsp["result"]=false;
+				}
+				wrtc_rsp["type"]= WRTC_CMD_SETTINGS;
+				lroot.append(wrtc_rsp);
+				wrtc_path = writer.write(lroot);
+
+				result += wrtc_path.c_str();
+				return result;
+			}
 			else if(strcasecmp(pname,WRTC_CMD_SET_RECORD_TIME) == 0)
 			{
 				int pvalue=root["value"].asInt();
diff --git a/src/storage/StorageManager.cpp b/src/storage/StorageManager.cpp
index e9f0449..0fa39a8 100755
--- a/src/storage/StorageManager.cpp
+++ b/src/storage/StorageManager.cpp
@@ -659,6 +659,63 @@ int StorageManager::generateFile(time_t &now, String8 &file, int cam_type, fileT
 	return fd;
 }
 
+int StorageManager::generateFile2(time_t now, String8 &file, int cam_type, fileType_t type)
+{
+
+    int fd;
+    struct tm *tm=NULL;
+    char buf[128]= {0};
+    char path_temp[128]= {0};
+    const char *camType = FILE_FRONT;
+    const char *suffix = FLAG_NONE;
+    const char *fileType = EXT_VIDEO_MP4;
+    const char *path = CON_2STRING(MOUNT_PATH, VIDEO_DIR);
+
+    file_threshold_t *threshlod_file = findThreshold(cam_type,type);
+    sprintf(path_temp,"%s%s/%s",MOUNT_PATH,threshlod_file->dir,THUMBNAIL_DIR);
+    path = path_temp;
+
+    if(isMount()== false)
+        return RET_NOT_MOUNT;
+    db_msg("%s %d", __FUNCTION__, __LINE__);
+
+    filelock.lock();
+    while(mFileMgrT == NULL)
+    {
+        mFileMgrT = new FileMgrThread(this);
+        status_t err = mFileMgrT->start();
+        if (err != OK) {
+            mFileMgrT.clear();
+            mFileMgrT = NULL;
+            db_msg("---FileMgrThread init error!!!!!");
+        }
+    }
+    thresholds.push_back(threshlod_file);
+    filelock.unlock();
+
+    tm = localtime(&now);
+
+    if (type == VIDEO_TYPE_IMPACT) {
+        suffix = FLAG_SOS;
+    }
+    if (type == PHOTO_TYPE_NORMAL) {
+        fileType = EXT_PIC_JPG;
+    }
+    if (cam_type == CAM_UVC) {
+        camType = FILE_BACK;
+    }
+    sprintf(buf, "%s%04d%02d%02d_%02d%02d%02d%s%s%s",path,tm->tm_year + 1900, tm->tm_mon + 1,
+            tm->tm_mday, tm->tm_hour,tm->tm_min, tm->tm_sec, camType, suffix, fileType);
+    file = buf;
+    fd = open(buf, O_RDWR | O_CREAT, 0666);
+    if (fd < 0) {
+        db_msg("failed to open file '%s'!!\n", buf);
+        return RET_IO_OPEN_FILE;
+    }
+    db_debug("generate file %s", file.string());
+    return fd;
+}
+
 int StorageManager::doMount(const char *fsPath, const char *mountPoint,
 		bool ro, bool remount, bool executable,
 		int ownerUid, int ownerGid, int permMask, bool createLost) {
diff --git a/src/window/MainWindow.cpp b/src/window/MainWindow.cpp
index 25d49b7..288732b 100755
--- a/src/window/MainWindow.cpp
+++ b/src/window/MainWindow.cpp
@@ -1538,6 +1538,13 @@ int CdrMain::setVideoModeWebRTC(int value)
 	return 0;
 }
 
+int CdrMain::setPicModeWebRTC(int value)
+{
+	mRecordPreview->setPictureQuality(value);
+	return 0;
+}
+
+
 int  CdrMain::setRecordTimeWebRTC(int value)
 {
 	ResourceManager* rm;
diff --git a/src/window/RecordPreview.cpp b/src/window/RecordPreview.cpp
index be5de82..7f3a902 100755
--- a/src/window/RecordPreview.cpp
+++ b/src/window/RecordPreview.cpp
@@ -306,6 +306,7 @@ void RecordPreview::takePicFinish(int cam_id)
 {
 	Mutex::Autolock _l(mLockPic);
 	mAllowTakePic[cam_id] = true;
+	isThumb = false;
 }
 
 
@@ -357,7 +358,6 @@ static void jpegCallback(void *data, int size, void* caller, int id)
 		return;
 	}
 	rp = (RecordPreview*)caller;
-
 	rp->savePicture(data, size, id);
 	rp->takePicFinish(id);
 
@@ -684,6 +684,12 @@ void RecordPreview::recordListener(CdrMediaRecorder* cmr, int what, int extra)
 			}
 			db_msg("Please set the next fd.");
 			fd = sm->generateFile(mBakNow[cameraID], mBakFileString[cameraID], cameraID, recordParam.video_type);
+			isThumb = true;
+			#ifdef MESSAGE_FRAMEWORK
+			fwk_send_message_ext(FWK_MOD_VIEW,FWK_MOD_CONTROL, MSG_ID_FWK_CONTROL_TAKE_PICTURE_REQ, NULL, 0);
+			#else
+			takePicture();
+			#endif
 			if(fd <= 0) {
 				db_error("get fd failed\n");
 				clrDeleteFlag(cameraID, mRecordDBInfo[cameraID].fileString);
@@ -1017,6 +1023,9 @@ RecordPreview::RecordPreview(CdrMain *cdrMain)
 	mOldRPWindowState(STATUS_RECORDPREVIEW), 
 	mUvcPlugFlag(false),
 	SdcardState(true),
+	isThumb(false),
+	pictuQuality(ImageQuality1080P),
+	thumbQuality(ImageQualityQQVGA),
 #ifdef WATERMARK_ENABLE
 	mNeedWaterMark(false),
 #endif
@@ -1677,8 +1686,20 @@ int RecordPreview::prepareRecord(int cam_type, CdrRecordParam_t param)
 	int framerate = BACK_CAM_FRAMERATE;
 	int i = 0;
 	StorageManager* sm = StorageManager::getInstance();
-
+	
+	isThumb = true;
+	mBakFileString[cam_type].clear();
+	mBakNow[cam_type] = 0;
+	
 	fd = sm->generateFile(now, file, cam_type, param.video_type);
+	mBakNow[0] = now;
+	mBakFileString[0] = file;
+	#ifdef MESSAGE_FRAMEWORK
+	fwk_send_message_ext(FWK_MOD_VIEW,FWK_MOD_CONTROL, MSG_ID_FWK_CONTROL_TAKE_PICTURE_REQ, NULL, 0);
+	#else
+	takePicture();
+	#endif
+	
 	if (fd <= 0) {
 		SdcardState = false;
 		db_error("fail to generate file, retval is %d\n", fd);
@@ -1786,8 +1807,6 @@ int RecordPreview::startRecord(int cam_type, CdrRecordParam_t param)
 			SendMessage(hStatusBar, STBM_START_RECORD_TIMER, 0, 0);
 		}
 #endif
-		mBakFileString[cam_type].clear();
-		mBakNow[cam_type] = 0;
 		retval = mRecorder[cam_type]->start();
                 mRecorder[cam_type]->setSilent(mSilent);
 	}
@@ -2021,6 +2040,11 @@ void RecordPreview::setVideoQuality(int idx)
 	}
 }
 
+void RecordPreview::setPictureQuality(int quality)
+{
+	pictuQuality = (ImageQuality_t)quality;
+}
+	
 void RecordPreview::setPicQuality(int idx)
 {
 	Mutex::Autolock _l(mLock);
@@ -2452,7 +2476,7 @@ void RecordPreview::takePicture()
 	StorageManager* sm;
 	ResourceManager* rm;
 	bool takePicture_status = false;
-
+	
 	if(mCamera[CAM_CSI] || mCamera[CAM_UVC]) {
 		sm = StorageManager::getInstance();
 		if(sm->isMount() == false) {
@@ -2470,13 +2494,23 @@ void RecordPreview::takePicture()
 			if (mCamera[CAM_CSI] && mCamera[CAM_CSI]->isPreviewing()) {
 				if (mAllowTakePic[CAM_CSI]) {
 					db_msg("csi take pic");
+					
+					if(isThumb == true)
+					{
+						mCamera[CAM_CSI]->setImageQuality(thumbQuality);
+					}
+					else
+					{
+						mCamera[CAM_CSI]->setImageQuality(pictuQuality);
+					}
+				
 					mAllowTakePic[CAM_CSI] = false;
 #ifdef HAVE_takePicture
 					mCamera[CAM_CSI]->takePicture();
 					takePicture_status = true;
 #endif
 				} else {
-					db_msg("uvc last action hasn't finished");
+					db_msg("csi last action hasn't finished");
 				}
 			}
 			if (mCamera[CAM_UVC] && mCamera[CAM_UVC]->isPreviewing()) {
@@ -2527,8 +2561,16 @@ void RecordPreview::savePicture(void*data, int size, int id)
 
 	sm = StorageManager::getInstance();
 	hStatusBar = mCdrMain->getWindowHandle(WINDOWID_STATUSBAR);
-
-	fd = sm->generateFile(now, file, id, PHOTO_TYPE_NORMAL);
+	
+	if(isThumb == true)
+	{
+		fd = sm->generateFile2(mBakNow[0], file, 0, PHOTO_TYPE_NORMAL);
+	}
+	else
+	{
+		fd = sm->generateFile(now, file, id, PHOTO_TYPE_NORMAL);
+	}
+	
 	if(fd <= 0) {
 		db_error("generate picture file failed, retval is %d\n", fd);
 		return;	
